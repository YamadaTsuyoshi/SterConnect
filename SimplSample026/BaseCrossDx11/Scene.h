/*!
@file Scene.h
@brief シーンなど
*/
#pragma once
#include "stdafx.h"

namespace basecross {

	class Scene;
	class GameObject;

	//--------------------------------------------------------------------------------------
	///	カメラ
	//--------------------------------------------------------------------------------------
	struct Camera {
		Vec3 m_CamerEye;			///<カメラ位置
		Vec3 m_CamerAt;			///<カメラ視点
		Vec3 m_CamerUp;			///<カメラ傾き
		float m_FovY;				///<画角
		float m_CameraXZRad;			//カメラのXZラジアン
		float m_CameraYRad;				//カメラのYラジアン
		float m_CameraArmLen;		//カメラの腕の長さ
		bool m_IsPerspective;			//遠近法を使うかどうか
		Camera():
			m_CamerEye(0, 0.25f, -50.0f),
			m_CamerAt(2.4, 0.25f, 0),
			m_CamerUp(0, 1.0f, 0),
			m_FovY(0.05f),
			m_CameraXZRad(0.0f),
			m_CameraYRad(XM_PIDIV2),
			m_CameraArmLen(bsm::length(m_CamerEye - m_CamerAt)),
			m_IsPerspective(false)
		{
		

		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief ビュー行列と射影行列の取得（各参照パラメータに代入）
		@param[out]	View	ビュー行列を受け取る参照
		@param[out]	Proj	射影行列を受け取る参照
		@return	なし
		*/
		//--------------------------------------------------------------------------------------
		void GetViewProjMatrix(Mat4x4& View, Mat4x4& Proj)const {
			if (m_IsPerspective) {
				View = XMMatrixLookAtLH(m_CamerEye, m_CamerAt, m_CamerUp);
				float w = static_cast<float>(App::GetApp()->GetGameWidth());
				float h = static_cast<float>(App::GetApp()->GetGameHeight());
				Proj = XMMatrixPerspectiveFovLH(m_FovY, w / h, 1.0f, 100.0f);
			}
			else {
				View = XMMatrixLookAtLH(m_CamerEye, m_CamerAt, m_CamerUp);
				float w = static_cast<float>(App::GetApp()->GetGameWidth());
				w /= 65;
				float h = static_cast<float>(App::GetApp()->GetGameHeight());
				h /= 65;

				Proj = XMMatrixOrthographicLH(w, h, 1.0f, 100.0f);

			}
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief カメラのEyeとAtを取得
		@param[out]	Eye	Eyeを受け取る参照
		@param[out]	At	Atを受け取る参照
		@return	なし
		*/
		//--------------------------------------------------------------------------------------
		void GetCameraEyeAt(Vec3& Eye, Vec3& At)const {
			Eye = m_CamerEye;
			At = m_CamerAt;
		}
	};

	//--------------------------------------------------------------------------------------
	//	シングルライト
	//--------------------------------------------------------------------------------------
	struct SingleLight {
		Vec3 m_Directional;	//ライトの向き
		Col4 m_DiffuseColor;	//ディフィーズ色
		Col4 m_SpecularColor;	//スペキュラー色
		Col4 m_AmbientLightColor;			//アンビエント色
		SingleLight()
		{
			SetDefaultLighting();
		}
		SingleLight(const Vec3& dir, const Col4& def, const Col4& sp, const Col4& am) :
			m_Directional(dir),
			m_DiffuseColor(def),
			m_SpecularColor(sp),
			m_AmbientLightColor(am)
		{
		}
		~SingleLight() {}
		//--------------------------------------------------------------------------------------
		/*!
		@brief ライト位置からの向きを設定する
		@param[in]	Position	ライトの位置
		@return	なし
		*/
		//--------------------------------------------------------------------------------------
		void SetPositionToDirectional(const Vec3& Position) {
			m_Directional = Position;
			m_Directional *= -1.0f;
			m_Directional.normalize();
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief ライト位置からの向きを設定する
		@param[in]	x	ライト位置x
		@param[in]	y	ライト位置y
		@param[in]	z	ライト位置z
		@return	なし
		*/
		//--------------------------------------------------------------------------------------
		void SetPositionToDirectional(float x, float y, float z) {
			m_Directional = bsm::Vec3(x, y, z);
			m_Directional *= -1.0f;
			m_Directional.normalize();
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief デフォルトのライティングを設定する
		@return	なし
		*/
		//--------------------------------------------------------------------------------------
		void SetDefaultLighting() {
			m_Directional = Vec3(0.4545195f, -0.7660444f,  0.4545195f);
			m_Directional.normalize();
			m_DiffuseColor = Col4(0.3231373f, 0.3607844f, 0.3937255f, 0.0f);
			m_SpecularColor = Col4(0.3231373f, 0.3607844f, 0.3937255f, 0.0f);
			m_AmbientLightColor = Col4( 0.05333332f, 0.09882354f, 0.1819608f ,0.0f );
		}
	};


	//--------------------------------------------------------------------------------------
	//	マルチライト
	//--------------------------------------------------------------------------------------
	struct MultiLights {
		Vec3 m_Directional[3];	//ライトの向き
		Col4 m_DiffuseColor[3];	//ディフィーズ色
		Col4 m_SpecularColor[3];	//スペキュラー色
		Col4 m_AmbientLightColor;			//アンビエント色
		size_t m_MainColorIndex;
		MultiLights()
		{
			SetDefaultLighting();
			m_MainColorIndex = 2;
		}
		~MultiLights() {}
		//--------------------------------------------------------------------------------------
		/*!
		@brief デフォルトのライティングを設定する
		@return	なし
		*/
		//--------------------------------------------------------------------------------------
		void SetDefaultLighting() {
			static const Vec3 defaultDirections[3] =
			{
				{ -0.5265408f, -0.5735765f, -0.6275069f },
				{ 0.7198464f,  0.3420201f,  0.6040227f },
				{ 0.4545195f, -0.7660444f,  0.4545195f },
			};
			static const Col4 defaultDiffuse[3] =
			{
				{ 1.0000000f, 0.9607844f, 0.8078432f,0.0f },
				{ 0.9647059f, 0.7607844f, 0.4078432f,0.0f },
				{ 0.3231373f, 0.3607844f, 0.3937255f,0.0f },
			};

			static const Col4 defaultSpecular[3] =
			{
				{ 1.0000000f, 0.9607844f, 0.8078432f,0.0f },
				{ 0.0000000f, 0.0000000f, 0.0000000f,0.0f },
				{ 0.3231373f, 0.3607844f, 0.3937255f,0.0f },
			};


			m_AmbientLightColor = Col4(0.05333332f, 0.09882354f, 0.1819608f, 0.0f);
			for (size_t i = 0; i < 3; i++) {
				m_Directional[i] = defaultDirections[i];
				m_Directional[i].normalize();
				m_DiffuseColor[i] = defaultDiffuse[i];
				m_SpecularColor[i] = defaultSpecular[i];
			}
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief メインのライトを取得する
		@param[out]	Light	受け取るライト
		@return	なし
		*/
		//--------------------------------------------------------------------------------------
		void GetMainLight(SingleLight& light) {
			light.m_Directional = m_Directional[m_MainColorIndex];
			light.m_DiffuseColor = m_DiffuseColor[m_MainColorIndex];
			light.m_SpecularColor = m_SpecularColor[m_MainColorIndex];
			light.m_AmbientLightColor = m_AmbientLightColor;
		}
	};

	class RigidbodyManager;
	struct Rigidbody;
	struct CollisionState;

	//--------------------------------------------------------------------------------------
	///	ステージ（シーンで管理するインターフェイス）
	//--------------------------------------------------------------------------------------
	class Stage : public ObjectInterface, public ShapeInterface {
		//マルチライト
		MultiLights m_MultiLights;
		//カメラ
		Camera m_Camera;
		//オブジェクトの配列
		vector< shared_ptr<GameObject> > m_GameObjectVec;
		//途中にオブジェクトが追加された場合、ターンの開始まで待つ配列
		vector< shared_ptr<GameObject> > m_WaitAddObjectVec;
		//途中にオブジェクトが削除された場合、ターンの開始まで待つ配列
		vector< shared_ptr<GameObject> > m_WaitRemoveObjectVec;
		//追加オブジェクトの指定
		void PushBackGameObject(const shared_ptr<GameObject>& Ptr);
		//削除オブジェクトの指定
		void RemoveBackGameObject(const shared_ptr<GameObject>& Ptr);
		//オブジェクトの削除
		void RemoveTargetGameObject(const shared_ptr<GameObject>& targetobj);
		//追加や削除待ちになってるオブジェクトを追加削除する
		void SetWaitToObjectVec();
	protected:
		//Rigidbodyマネージャ
		shared_ptr<RigidbodyManager> m_RigidbodyManager;
		//--------------------------------------------------------------------------------------
		/*!
		@brief プロテクトコンストラクタ
		*/
		//--------------------------------------------------------------------------------------
		Stage(){
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief デストラクタ
		*/
		//--------------------------------------------------------------------------------------
		virtual ~Stage() {}
	public:
		//--------------------------------------------------------------------------------------
		/*!
		@brief カメラの取得
		@return	カメラの参照
		*/
		//--------------------------------------------------------------------------------------
		const Camera& GetCamera()const {
			return m_Camera;
		}
		Camera& GetCamera() {
			return m_Camera;
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief メインライト向きの取得
		@param[out]	LightDir	ライト向き受け取る参照
		@return	なし
		*/
		//--------------------------------------------------------------------------------------
		void GetLightDir(Vec4& LightDir)const {
			LightDir = m_MultiLights.m_Directional[m_MultiLights.m_MainColorIndex];
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief マルチライトの取得
		@return	マルチライトの参照
		*/
		//--------------------------------------------------------------------------------------
		const MultiLights& GetMultiLights()const {
			return m_MultiLights;
		}
		MultiLights& GetMultiLights() {
			return m_MultiLights;
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief 前初期化
		@return	なし
		*/
		//--------------------------------------------------------------------------------------
		virtual void OnPreCreate() override;
		//--------------------------------------------------------------------------------------
		/*!
		@brief ステージ更新準備（仮想関数）
		@return	なし
		*/
		//--------------------------------------------------------------------------------------
		virtual void OnPreUpdateStage() {
			SetWaitToObjectVec();
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief ステージ更新（純粋仮想関数）
		@return	なし
		*/
		//--------------------------------------------------------------------------------------
		virtual void OnUpdateStage() = 0;
		//--------------------------------------------------------------------------------------
		/*!
		@brief ステージ描画（純粋仮想関数）
		@return	なし
		*/
		//--------------------------------------------------------------------------------------
		virtual void OnDrawStage() = 0;
		//--------------------------------------------------------------------------------------
		/*!
		@brief	ゲームオブジェクトを追加する
		@tparam	T	作成する型
		@tparam	Ts	可変長パラメータの型
		@param[in]	params	可変長パラメータ
		@return	作成されたゲームオブジェクト
		*/
		//--------------------------------------------------------------------------------------
		template<typename T, typename... Ts>
		shared_ptr<T> AddGameObject(Ts&&... params) {
			try {
				auto Ptr = ObjectFactory::Create<T>(GetThis<Stage>(), params...);
				PushBackGameObject(Ptr);
				return Ptr;
			}
			catch (...) {
				throw;
			}
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	ゲームオブジェクトの配列を得る
		@return	ゲームオブジェクトの配列
		*/
		//--------------------------------------------------------------------------------------
		const vector< shared_ptr<GameObject> >& GetGameObjectVec()const {
			return m_GameObjectVec;
		}
		vector< shared_ptr<GameObject> >& GetGameObjectVec() {
			return m_GameObjectVec;
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	インスタンスからそのゲームオブジェクトが指定した型かどうかを得る
		@tparam	T	調べる型
		@param[in]	Obj	インスタンス
		@return	指定した型で存在すればtrue
		*/
		//--------------------------------------------------------------------------------------
		template<typename T>
		bool FindGameObject(const shared_ptr<GameObject>& Obj) const{
			auto shptr = dynamic_pointer_cast<T>(Obj);
			if (shptr) {
				for (auto ptr : GetGameObjectVec()) {
					if (Obj == ptr) {
						return true;
					}
				}
			}
			return false;
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	タグを持つそのゲームオブジェクトを得る
		@tparam	T	調べる型
		@param[in]	TagName	タグ名
		@param[in]	ExceptionActive	対象がnullだった場合に例外処理するかどうか
		@return	 指定のタグを持つ最初のオブジェクト（保存してはいけない）
		*/
		//--------------------------------------------------------------------------------------
		template<typename T>
		shared_ptr<T> FindTagGameObject(const wstring& TagName,bool ExceptionActive = true) const {
			for (auto& v : GetGameObjectVec()) {
				if (v->FindTag(TagName)) {
					auto shptr = dynamic_pointer_cast<T>(v);
					if (shptr) {
						return shptr;
					}
				}
			}
			if (ExceptionActive) {
				throw BaseException(
					L"オブジェクトが見つかりません",
					TagName,
					L"Stage::FindGameObject()"
				);
			}
			return nullptr;
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	タグからそのゲームオブジェクトを得る
		@param[in]	TagName	タグ名
		@param[out]	Ret GameObjectの配列(shared_ptrの配列)
		@return	 指定のタグを持つオブジェクトの配列を得る。使用後は速やかに解放すること
		*/
		//--------------------------------------------------------------------------------------
		void FindTagGameObjectVec(const wstring& TagName, vector<shared_ptr<GameObject>>& Ret) const;
		//--------------------------------------------------------------------------------------
		/*!
		@brief	ゲームオブジェクトを削除する
		@tparam	T	削除する型
		@param[in]	Obj	インスタンス
		@return	なし
		*/
		//--------------------------------------------------------------------------------------
		template<typename T>
		void RemoveGameObject(const shared_ptr<GameObject>& Obj) {
			if (FindGameObject<T>(Obj)) {
				RemoveBackGameObject(Obj);
			}
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	Rigidbodyマネージャを得る
		@return	Rigidbodyマネージャ
		*/
		//--------------------------------------------------------------------------------------
		shared_ptr<RigidbodyManager> GetRigidbodyManager() const;
		//--------------------------------------------------------------------------------------
		/*!
		@brief Rigidbodyを登録する
		@return	追加したRigidbodyのshared_ptr
		*/
		//--------------------------------------------------------------------------------------
		shared_ptr<Rigidbody> AddRigidbody(const Rigidbody& body);
		//--------------------------------------------------------------------------------------
		/*!
		@brief 指定のオーナーのRigidbodyを削除する（見つからなければ何もしない）
		@param[in]	OwnerPtr	オーナーのポインタ
		@return	なし
		*/
		//--------------------------------------------------------------------------------------
		void RemoveOwnRigidbody(const shared_ptr<GameObject>& OwnerPtr);
		//--------------------------------------------------------------------------------------
		/*!
		@brief Rigidbodyの配列を得る
		@return	Rigidbodyの配列
		*/
		//--------------------------------------------------------------------------------------
		const vector<shared_ptr<Rigidbody>>& GetRigidbodyVec()const;
		//--------------------------------------------------------------------------------------
		/*!
		@brief 衝突情報の配列を得る
		@return	衝突情報の配列
		*/
		//--------------------------------------------------------------------------------------
		const vector<CollisionState>& GetCollisionStateVec()const;
		//--------------------------------------------------------------------------------------
		/*!
		@brief 指定のオーナーのRigidbodyを得る
		@param[in]	OwnerPtr	オーナーのポインタ
		@return	指定のオーナーのRigidbodyのshared_ptr
		*/
		//--------------------------------------------------------------------------------------
		shared_ptr<Rigidbody> GetOwnRigidbody(const shared_ptr<GameObject>& OwnerPtr);
	};


	//--------------------------------------------------------------------------------------
	///	変換オブジェクト
	//--------------------------------------------------------------------------------------
	class Transform : public ObjectInterface, public ShapeInterface {
	public:
		//--------------------------------------------------------------------------------------
		/*!
		@brief	ゲームオブジェクトの取得
		@return	このコンポーネントを所持するゲームオブジェクト
		*/
		//--------------------------------------------------------------------------------------
		shared_ptr<GameObject> GetGameObject() const;
		//--------------------------------------------------------------------------------------
		/*!
		@brief	ステージの取得<br />
		ゲームオブジェクトがステージだった場合、そのステージが返る
		@return	このコンポーネントを所持するゲームオブジェクトが所属するステージ
		*/
		//--------------------------------------------------------------------------------------
		shared_ptr<Stage> GetStage() const;
		//--------------------------------------------------------------------------------------
		/*!
		@brief	Updateがアクティブかどうかを得る
		@return	アクティブならtrue
		*/
		//--------------------------------------------------------------------------------------
		bool IsUpdateActive() const;
		//--------------------------------------------------------------------------------------
		/*!
		@brief	Updateがアクティブかどうかを得る
		@return	アクティブならtrue
		*/
		//--------------------------------------------------------------------------------------
		bool GetUpdateActive() const;
		//--------------------------------------------------------------------------------------
		/*!
		@brief	Updateがアクティブかどうかを設定する
		@param[in]	b	アクティブかどうか
		@return	なし
		*/
		//--------------------------------------------------------------------------------------
		void SetUpdateActive(bool b);
		//--------------------------------------------------------------------------------------
		/*!
		@brief	Drawがアクティブかどうかを得る
		@return	アクティブならtrue
		*/
		//--------------------------------------------------------------------------------------
		bool IsDrawActive() const;
		//--------------------------------------------------------------------------------------
		/*!
		@brief	Drawがアクティブかどうかを得る
		@return	アクティブならtrue
		*/
		//--------------------------------------------------------------------------------------
		bool GetDrawActive() const;
		//--------------------------------------------------------------------------------------
		/*!
		@brief	Drawがアクティブかどうかを設定する
		@param[in]	b	アクティブかどうか
		@return	なし
		*/
		//--------------------------------------------------------------------------------------
		void SetDrawActive(bool b);
		//構築と破棄
		//--------------------------------------------------------------------------------------
		/*!
		@brief	コンストラクタ
		@param[in]	GameObjectPtr	このコンポーネントを所持するゲームオブジェクト
		*/
		//--------------------------------------------------------------------------------------
		explicit Transform(const shared_ptr<GameObject>& GameObjectPtr);
		//--------------------------------------------------------------------------------------
		/*!
		@brief	デストラクタ
		*/
		//--------------------------------------------------------------------------------------
		virtual ~Transform();
		//アクセサ
		//--------------------------------------------------------------------------------------
		/*!
		@brief	1ターン前のスケーリングを得る
		@return	1ターン前のスケーリング
		*/
		//--------------------------------------------------------------------------------------
		bsm::Vec3 GetBeforeScale() const;
		//--------------------------------------------------------------------------------------
		/*!
		@brief	1つ前の重心を得る
		@return	1つ前の重心
		*/
		//--------------------------------------------------------------------------------------
		bsm::Vec3 GetBeforePivot() const;
		//--------------------------------------------------------------------------------------
		/*!
		@brief	1ターン前のワールド回転を得る
		@return	1ターン前のワールド回転
		*/
		//--------------------------------------------------------------------------------------
		bsm::Quat GetBeforeQuaternion() const;
		//--------------------------------------------------------------------------------------
		/*!
		@brief	1ターン前のワールド回転を得る
		@return	1ターン前のワールド回転（ベクトル）
		*/
		//--------------------------------------------------------------------------------------
		bsm::Vec3 GetBeforeRotation() const;
		//--------------------------------------------------------------------------------------
		/*!
		@brief	1ターン前のワールド位置を得る
		@return	1ターン前のワールド位置
		*/
		//--------------------------------------------------------------------------------------
		bsm::Vec3 GetBeforePosition() const;
		//--------------------------------------------------------------------------------------
		/*!
		@brief	1つ前のワールド行列と同じかどうかを得る
		@param	mat	調べる行列
		@return	同じならtrue
		*/
		//--------------------------------------------------------------------------------------
		bool IsSameBeforeWorldMatrix(const bsm::Mat4x4& mat) const;
		//--------------------------------------------------------------------------------------
		/*!
		@brief	1つ前のワールド行列を得る
		@return	1つ前のワールド行列
		*/
		//--------------------------------------------------------------------------------------
		const bsm::Mat4x4& GetBeforeWorldMatrix() const;
		//--------------------------------------------------------------------------------------
		/*!
		@brief	スケーリングを得る
		@return	スケーリング
		*/
		//--------------------------------------------------------------------------------------
		bsm::Vec3 GetScale() const;
		//--------------------------------------------------------------------------------------
		/*!
		@brief	スケーリングを設定する.
		@param	const bsm::Vec3& Scale	スケーリング
		@return	なし
		*/
		//--------------------------------------------------------------------------------------
		void SetScale(const bsm::Vec3& Scale);
		//--------------------------------------------------------------------------------------
		/*!
		@brief	スケーリングを設定する.
		@param[in]	x	Xスケーリング
		@param[in]	y	Yスケーリング
		@param[in]	z	Zスケーリング
		@return	なし
		*/
		//--------------------------------------------------------------------------------------
		void SetScale(float x, float y, float z);
		//--------------------------------------------------------------------------------------
		/*!
		@brief	重心を得る
		@return	重心
		*/
		//--------------------------------------------------------------------------------------
		bsm::Vec3 GetPivot() const;
		//--------------------------------------------------------------------------------------
		/*!
		@brief	重心を設定する.
		@param	Pivot	重心
		@return	なし
		*/
		//--------------------------------------------------------------------------------------
		void SetPivot(const bsm::Vec3& Pivot);
		//--------------------------------------------------------------------------------------
		/*!
		@brief	重心を設定する.
		@param[in]	x	X重心
		@param[in]	y	Y重心
		@param[in]	z	Z重心
		@return	なし
		*/
		//--------------------------------------------------------------------------------------
		void SetPivot(float x, float y, float z);
		//--------------------------------------------------------------------------------------
		/*!
		@brief	ワールド回転を得る
		@return	ワールド回転（クオータニオン）
		*/
		//--------------------------------------------------------------------------------------
		bsm::Quat GetQuaternion() const;
		//--------------------------------------------------------------------------------------
		/*!
		@brief	ワールド回転を設定する
		@param[in]	quaternion	クオータニオン
		@return	なし
		*/
		//--------------------------------------------------------------------------------------
		void SetQuaternion(const bsm::Quat& quaternion);
		//--------------------------------------------------------------------------------------
		/*!
		@brief	ワールド回転を得る
		@return	ワールド回転（ベクトル）
		*/
		//--------------------------------------------------------------------------------------
		bsm::Vec3 GetRotation() const;
		//--------------------------------------------------------------------------------------
		/*!
		@brief	ワールド回転を設定する
		@param[in]	Rot	回転ベクトル
		@return	なし
		*/
		//--------------------------------------------------------------------------------------
		void SetRotation(const bsm::Vec3& Rot);
		//--------------------------------------------------------------------------------------
		/*!
		@brief	ワールド回転を設定する
		@param[in]	x	X回転
		@param[in]	y	Y回転
		@param[in]	z	Z回転
		@return	なし
		*/
		//--------------------------------------------------------------------------------------
		void SetRotation(float x, float y, float z);
		//--------------------------------------------------------------------------------------
		/*!
		@brief	位置を得る
		@return	位置
		*/
		//--------------------------------------------------------------------------------------
		bsm::Vec3 GetPosition() const;
		//--------------------------------------------------------------------------------------
		/*!
		@brief	位置を設定する
		@param[in]	Position	設定する位置
		@return	なし
		*/
		//--------------------------------------------------------------------------------------
		void SetPosition(const bsm::Vec3& Position);
		//--------------------------------------------------------------------------------------
		/*!
		@brief	位置を設定する
		@param[in]	x	X位置
		@param[in]	y	Y位置
		@param[in]	z	Z位置
		@return	なし
		*/
		//--------------------------------------------------------------------------------------
		void SetPosition(float x, float y, float z);
		//--------------------------------------------------------------------------------------
		/*!
		@brief	位置と一つ前の位置を設定する
		@param[in]	Position	設定する位置
		@return	なし
		*/
		//--------------------------------------------------------------------------------------
		void ResetPosition(const bsm::Vec3& Position);
		//--------------------------------------------------------------------------------------
		/*!
		@brief	ワールド位置を得る
		@return	ワールド位置
		*/
		//--------------------------------------------------------------------------------------
		bsm::Vec3 GetWorldPosition() const;
		//--------------------------------------------------------------------------------------
		/*!
		@brief	ワールド位置を設定する
		@param[in]	Position	設定する位置
		@return	なし
		*/
		//--------------------------------------------------------------------------------------
		void SetWorldPosition(const bsm::Vec3& Position);
		//--------------------------------------------------------------------------------------
		/*!
		@brief	ワールド位置と一つ前のワールド位置を設定する
		@param[in]	Position	設定する位置
		@return	なし
		*/
		//--------------------------------------------------------------------------------------
		void ResetWorldPosition(const bsm::Vec3& Position);
		//--------------------------------------------------------------------------------------
		/*!
		@brief	ワールド行列と同じかどうかを得る
		@param	mat	調べる行列
		@return	同じならtrue
		*/
		//--------------------------------------------------------------------------------------
		bool IsSameWorldMatrix(const bsm::Mat4x4& mat) const;
		//--------------------------------------------------------------------------------------
		/*!
		@brief	ワールド行列を得る
		@return	ワールド行列
		*/
		//--------------------------------------------------------------------------------------
		const bsm::Mat4x4& GetWorldMatrix() const;
		//--------------------------------------------------------------------------------------
		/*!
		@brief	2D用の計算されたワールド行列を得る
		@return	2D用の計算されたワールド行列
		*/
		//--------------------------------------------------------------------------------------
		const bsm::Mat4x4& Get2DWorldMatrix() const;
		//--------------------------------------------------------------------------------------
		/*!
		@brief	親オブジェクトを得る
		@return	親オブジェクト（nullptrの場合あり）
		*/
		//--------------------------------------------------------------------------------------
		const shared_ptr<GameObject> GetParent()const;
		//--------------------------------------------------------------------------------------
		/*!
		@brief	親オブジェクトを設定する
		@param[in]	Obj	親オブジェクト
		@return	なし
		*/
		//--------------------------------------------------------------------------------------
		void SetParent(const shared_ptr<GameObject>& Obj);
		//--------------------------------------------------------------------------------------
		/*!
		@brief	親オブジェクトをクリアする
		@return	なし
		*/
		//--------------------------------------------------------------------------------------
		void ClearParent();
		//--------------------------------------------------------------------------------------
		/*!
		@brief	Transfoem上で計算した速度を得る
		@return	Transfoem上で計算した速度
		*/
		//--------------------------------------------------------------------------------------
		bsm::Vec3 GetVelocity() const;
		//--------------------------------------------------------------------------------------
		/*!
		@brief 情報を一つ前に移す<br />
		各情報はターンごとに1つ前のターン時の情報を持つ<br />
		この関数はその処理を行う
		@return	なし
		*/
		//--------------------------------------------------------------------------------------
		void SetToBefore();
		//操作
		//--------------------------------------------------------------------------------------
		/*!
		@brief 初期化を行う（仮想関数<br />
		＊thisポインタが必要なオブジェクトはこの関数を多重定義して、取得できる<br />
		＊ここでは空関数にしておくので、必要な場合は派生クラスで多重定義する
		@return	なし
		*/
		//--------------------------------------------------------------------------------------
		virtual void OnCreate() {}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	更新処理
		@return	なし
		*/
		//--------------------------------------------------------------------------------------
		virtual void OnUpdate()override;
		//--------------------------------------------------------------------------------------
		/*!
		@brief	描画処理。デフォルトは何も行わない
		@return	なし
		*/
		//--------------------------------------------------------------------------------------
		virtual void OnDraw()override {}
	private:
		// pImplイディオム
		struct Impl;
		unique_ptr<Impl> pImpl;
	};


	//--------------------------------------------------------------------------------------
	///	ゲームオブジェクトの親
	//--------------------------------------------------------------------------------------
	class GameObject : public ObjectInterface, public ShapeInterface {
		weak_ptr<Stage> m_Stage;	//所属ステージ
		set<wstring> m_Tag;	//タグ
							//Transform
		shared_ptr<Transform> m_Transform;
		bool m_UpdateActive;
		bool m_DrawActive;
		bool m_AlphaActive;
		bool m_SpriteDraw;
	protected:
		//--------------------------------------------------------------------------------------
		/*!
		@brief プロテクトコンストラクタ
		@param[in]	StagePtr	ステージ
		*/
		//--------------------------------------------------------------------------------------
		explicit GameObject(const shared_ptr<Stage>& StagePtr) :
			m_Stage(StagePtr),
			m_UpdateActive(true),
			m_DrawActive(true),
			m_AlphaActive(true)
		{}
		//--------------------------------------------------------------------------------------
		/*!
		@brief デストラクタ
		*/
		//--------------------------------------------------------------------------------------
		virtual ~GameObject() {}
	public:
		//--------------------------------------------------------------------------------------
		/*!
		@brief	所属するステージを得る
		@return	所属するステージ
		*/
		//--------------------------------------------------------------------------------------
		shared_ptr<Stage> GetStage() const {
			auto shptr = m_Stage.lock();
			if (!shptr) {
				throw BaseException(
					L"所属ステージがnullです。",
					L"if (!shptr)",
					L"GameObject::GetStage()"
				);
			}
			return shptr;
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	所属するステージを得る(型チェックあり)
		@return	所属するステージ
		*/
		//--------------------------------------------------------------------------------------
		template<typename T>
		shared_ptr<T> GetStage() const {
			auto StagePtr = GetStage();
			auto TargetPtr = dynamic_pointer_cast<T>(StagePtr);
			if (!TargetPtr) {
				throw BaseException(
					L"ステージがありましたが、型キャストできません",
					Util::GetWSTypeName<T>(),
					L"GameObject::GetStage<T>()"
				);
			}
			return TargetPtr;
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	タグのセットを得る
		@return	タグのセット
		*/
		//--------------------------------------------------------------------------------------
		const set<wstring>& GetTagSet()const {
			return m_Tag;
		}
		set<wstring>& GetTagSet() {
			return m_Tag;
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	指定するタグが存在するかどうかを得る
		@param[in]	tagstr	検証するタグ
		@return	存在すればtrue
		*/
		//--------------------------------------------------------------------------------------
		bool FindTag(const wstring& tagstr) const {
			if (m_Tag.find(tagstr) == m_Tag.end()) {
				return false;
			}
			return true;
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	指定するタグを追加する
		@param[in]	tagstr	追加するタグ
		@return	なし
		*/
		//--------------------------------------------------------------------------------------
		void  AddTag(const wstring& tagstr) {
			if (tagstr == L"") {
				//空白なら例外
				throw BaseException(
					L"設定するタグが空です",
					L"if (tagstr == L"")",
					L"GameObject::AddTag()"
				);
			}
			m_Tag.insert(tagstr);
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	指定するタグが存在したら削除する（存在しない場合は何もしない）
		@param[in]	tagstr	削除するタグ
		@return	なし
		*/
		//--------------------------------------------------------------------------------------
		void  RemoveTag(const wstring& tagstr) {
			m_Tag.erase(tagstr);
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	オブジェクトの位置を得る（仮想関数）
		@return	オブジェクトの位置
		*/
		//--------------------------------------------------------------------------------------
		virtual Vec3 GetPosition() {
			return Vec3(0, 0, 0);
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	シャドウマップの描画処理(仮想関数)
		@return	なし
		*/
		//--------------------------------------------------------------------------------------
		virtual void OnDrawShadowmap() {}
		//--------------------------------------------------------------------------------------
		/*!
		@brief 前初期化を行う（仮想関数）
		@return	なし
		*/
		//--------------------------------------------------------------------------------------
		virtual void OnPreCreate();
		//--------------------------------------------------------------------------------------
		/*!
		@brief	Transformを得る
		@return	Transformのポインタ
		*/
		//--------------------------------------------------------------------------------------
		shared_ptr<Transform> GetTransform()const {
			return m_Transform;
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	更新処理が有効かどうかを得る
		@return	更新処理が有効ならtrue
		*/
		//--------------------------------------------------------------------------------------
		bool IsUpdateActive() const {
			return m_UpdateActive;
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	更新処理が有効かどうかを設定する
		@param[in]	b	更新処理が有効ならならtrue
		@return	なし
		*/
		//--------------------------------------------------------------------------------------
		void SetUpdateActive(bool b) {
			m_UpdateActive = b;
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	描画処理が有効かどうかを得る
		@return	描画処理が有効ならtrue
		*/
		//--------------------------------------------------------------------------------------
		bool IsDrawActive() const {
			return m_DrawActive;
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	描画処理が有効かどうかを設定する
		@param[in]	b	描画処理が有効ならならtrue
		@return	なし
		*/
		//--------------------------------------------------------------------------------------
		void SetDrawActive(bool b) {
			m_DrawActive = b;
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	透明処理（半透明含む）が有効かどうかを得る
		@return	透明処理（半透明含む）が有効ならtrue
		*/
		//--------------------------------------------------------------------------------------
		bool IsAlphaActive() const {
			return m_AlphaActive;

		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	透明処理（半透明含む）が有効かどうかを設定する
		@param[in]	b	透明処理（半透明含む）が有効ならならtrue
		@return	なし
		*/
		//--------------------------------------------------------------------------------------
		void SetAlphaActive(bool b) {
			m_AlphaActive = b;
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	スプライトとしてDrawするかどうかを得る
		@return	スプライトとしてDrawするならtrue
		*/
		//--------------------------------------------------------------------------------------
		bool IsSpriteDraw() const {
			return m_SpriteDraw;
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	スプライトとしてDrawするかどうかを設定する
		@param[in]	b	スプライトとしてDrawするならtrue
		@return	なし
		*/
		//--------------------------------------------------------------------------------------
		void SetSpriteDraw(bool b) {
			m_SpriteDraw = b;
		}
	};
	//--------------------------------------------------------------------------------------
	///	ゲームシーン
	//--------------------------------------------------------------------------------------
	class Scene : public SceneInterface {
		//アクティブなステージ
		shared_ptr<Stage> m_ActiveStage;
		//--------------------------------------------------------------------------------------
		/*!
		@brief	アクティブなステージを設定して初期化する
		@tparam	T	取得する型（Stageに型変換できるもの）
		@tparam	Ts	可変長変数の型
		@param[in]	params	このステージを構築するのに使用するパラメータ。
		@return	ステージ
		*/
		//--------------------------------------------------------------------------------------
		template<typename T, typename... Ts>
		shared_ptr<T> ResetActiveStage(Ts&&... params) {
			auto Ptr = ObjectFactory::Create<T>(params...);
			auto StagePtr = dynamic_pointer_cast<Stage>(Ptr);
			if (!StagePtr) {
				throw BaseException(
					L"以下はStageに型キャストできません。",
					Util::GetWSTypeName<T>(),
					L"Scene::ResetActiveStage<T>()"
				);
			}
			m_ActiveStage = StagePtr;
			return Ptr;
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	リソースの作成
		@return	なし
		*/
		//--------------------------------------------------------------------------------------
		void CreateResources();
		int m_StageNumberCount = 1;
		int m_StageNumber;
		float m_CTime_Sec;
		float m_CTime_Min;
		float m_EnemyBreak;
		wstring m_DirectoryFile;
	public:
		//--------------------------------------------------------------------------------------
		/*!
		@brief コンストラクタ
		*/
		//--------------------------------------------------------------------------------------
		Scene();
		//--------------------------------------------------------------------------------------
		/*!
		@brief デストラクタ
		*/
		//--------------------------------------------------------------------------------------
		virtual ~Scene() {}
		//--------------------------------------------------------------------------------------
		/*!
		@brief アクティブなステージの取得
		@return	アクティブなステージ
		*/
		//--------------------------------------------------------------------------------------
		shared_ptr<Stage> GetActiveStage() const {
			if (!m_ActiveStage) {
				throw BaseException(
					L"アクティブなステージはありません",
					L"f (!m_ActiveStage)",
					L"Scene::GetActiveStage()"
				);
			}
			return m_ActiveStage;
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief 初期化
		@return	なし
		*/
		//--------------------------------------------------------------------------------------
		virtual void OnCreate() override;
		//--------------------------------------------------------------------------------------
		/*!
		@brief 更新
		@return	なし
		*/
		//--------------------------------------------------------------------------------------
		virtual void OnUpdate()override;
		//--------------------------------------------------------------------------------------
		/*!
		@brief 描画
		@return	なし
		*/
		//--------------------------------------------------------------------------------------
		virtual void OnDraw()override;
		//--------------------------------------------------------------------------------------
		/*!
		@brief イベント取得
		@return	なし
		*/
		//--------------------------------------------------------------------------------------
		virtual void OnEvent(const shared_ptr<Event>& event) override;

		
		void SetStageNumber(int StageNumber) {
			m_StageNumber = StageNumber;
		}
		int GetStageNumber() {
			return m_StageNumber;
		}

		void SetCTime_Sec(float t) {
			m_CTime_Sec = t;
		}
		void SetCTime_Min(float t) {
			m_CTime_Min = t;
		}
		float GetCTime_Sec() {
			return m_CTime_Sec;
		}
		float GetCTime_Min() {
			return m_CTime_Min;
		}

		void SetEnemyBreak(float num) {
			m_EnemyBreak = num;
		}
		float GetEnemyBreak() {
			return m_EnemyBreak;
		}

		void SetDirectoryFile(wstring DirectoryFile) {
			m_DirectoryFile = DirectoryFile;
		}
		wstring GetDirectoryFile() {
			return m_DirectoryFile;
		}
		int GetStageNumberCount() {
			return m_StageNumberCount;
		}
	};


}
// end basecross
